// Добавляем GSAP для анимаций
const gsap = window.gsap || {
    utils: {
        clamp: (min, max, value) => Math.min(Math.max(value, min), max)
    }
};

// Создаем общий загрузчик изображений
const imageLoader = {
    cache: new Map(),
    
    async load(url) {
        if (this.cache.has(url)) return this.cache.get(url);
        return new Promise(resolve => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                this.cache.set(url, img);
                resolve(img);
            };
            img.onerror = () => {
                console.error('Failed to load image:', url);
                resolve(null);
            };
            img.src = url;
        });
    }
};

// Добавляем стили для управления видимостью текста
const style = document.createElement('style');
style.textContent = `
    /* Скрываем текст до завершения анимации */
    [data-gallery-text] {
        visibility: hidden !important;
        opacity: 0 !important;
        transition: none !important;
    }
    
    /* Показываем текст только после завершения анимации */
    body:not(.initial-animation) [data-gallery-text] {
        visibility: visible !important;
        opacity: 1 !important;
        transition: visibility 0.3s, opacity 0.3s !important;
    }
`;
document.head.appendChild(style);

// Шейдеры встроены в скрипт
const VERTEX_SHADER = `
attribute vec4 aPosition;
attribute vec2 aTexCoord;
varying vec2 vUv;
varying vec2 vScreenPosition;

void main() {
    gl_Position = aPosition;
    vUv = aTexCoord;
    vScreenPosition = aPosition.xy;
}`;

const FRAGMENT_SHADER = `
precision highp float;

uniform float uTime;
uniform vec2 uResolution;
uniform sampler2D uTexture;
uniform sampler2D uTextureNext;
uniform float uTransition;
uniform vec2 uMousePosition;
uniform float uDirection;
varying vec2 vUv;
varying vec2 vScreenPosition;

#define PI 3.1415926535897932384626433832795

vec3 obj_pos = vec3(0.0, 0.0, -10.0);
float obj_size = 5.0;

vec3 getFishEye(vec2 uv, float level) {
    float len = length(uv);
    float a = len * level;
    return vec3(uv / len * sin(a), -cos(a));
}

vec3 textureAVG(sampler2D tex, vec2 tc) {
    const float diff0 = 0.35;
    const float diff1 = 0.12;
    vec2 flippedCoord = vec2(tc.x, 1.0 - tc.y);
    vec3 s0 = texture2D(tex, flippedCoord).xyz;
    vec3 s1 = texture2D(tex, (vec2(flippedCoord.x + diff0, flippedCoord.y))).xyz;
    vec3 s2 = texture2D(tex, (vec2(flippedCoord.x - diff0, flippedCoord.y))).xyz;
    vec3 s3 = texture2D(tex, (vec2(flippedCoord.x - diff0, flippedCoord.y + diff0))).xyz;
    vec3 s4 = texture2D(tex, (vec2(flippedCoord.x + diff0, flippedCoord.y - diff0))).xyz;
    
    vec3 s5 = texture2D(tex, (vec2(flippedCoord.x + diff1, flippedCoord.y))).xyz;
    vec3 s6 = texture2D(tex, (vec2(flippedCoord.x - diff1, flippedCoord.y))).xyz;
    vec3 s7 = texture2D(tex, (vec2(flippedCoord.x - diff1, flippedCoord.y + diff1))).xyz;
    vec3 s8 = texture2D(tex, (vec2(flippedCoord.x + diff1, flippedCoord.y - diff1))).xyz;
    
    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;
}

vec3 getColor(vec3 ray, sampler2D tex) {
    vec2 baseUV = ray.xy;
    baseUV = (baseUV + 1.0) * 0.5;
    
    float containerAspect = uResolution.x / uResolution.y;
    float scale = 1.0;
    
    if (containerAspect < 1.0) {
        scale = containerAspect;
        baseUV.x = baseUV.x * scale + (1.0 - scale) * 0.5;
    } else {
        scale = 1.0 / containerAspect;
        baseUV.y = baseUV.y * scale + (1.0 - scale) * 0.5;
    }
    
    baseUV.y = 1.0 - baseUV.y;
    vec3 baseColor = texture2D(tex, baseUV).xyz;
    return baseColor;
}

void main() {
    vec2 uv = vScreenPosition.xy;
    vec3 dir = getFishEye(uv, 1.4);
    vec3 color;
    
    // Горизонтальное и вертикальное движение
    float mouseX = -(uMousePosition.x - 0.5);
    float mouseY = -(uMousePosition.y - 0.5); // Добавляем вертикальное движение
    float mouseInfluenceX = 0.3; // Горизонтальное влияние
    float mouseInfluenceY = 0.2; // Уменьшенное вертикальное влияние
    
    // Создаем матрицы поворота для обоих направлений
    float mouseRotationX = mouseX * mouseInfluenceX * PI;
    float mouseRotationY = mouseY * mouseInfluenceY * PI;
    
    float transitionRotation = uTransition * PI * 2.0 * uDirection;
    
    // Матрица для горизонтального поворота
    mat2 mouseRotationMatrixX = mat2(
        cos(mouseRotationX), -sin(mouseRotationX),
        sin(mouseRotationX), cos(mouseRotationX)
    );
    
    // Матрица для вертикального поворота
    mat2 mouseRotationMatrixY = mat2(
        cos(mouseRotationY), -sin(mouseRotationY),
        sin(mouseRotationY), cos(mouseRotationY)
    );
    
    mat2 transitionRotationMatrix = mat2(
        cos(transitionRotation), -sin(transitionRotation),
        sin(transitionRotation), cos(transitionRotation)
    );
    
    // Применяем оба поворота
    dir.xz = mouseRotationMatrixX * dir.xz;  // горизонтальный поворот
    dir.yz = mouseRotationMatrixY * dir.yz;  // вертикальный поворот
    dir.xz = transitionRotationMatrix * dir.xz;
    
    // Плавное смешивание текстур
    vec3 currentColor = getColor(dir, uTexture);
    vec3 nextColor = getColor(dir, uTextureNext);
    
    // Используем простой линейный переход вместо сложной логики с модулем угла
    float mixFactor = smoothstep(0.0, 1.0, uTransition);
    
    // Смешиваем текстуры
    color = mix(currentColor, nextColor, mixFactor);
    
    float fish_eye = smoothstep(2.0, 1.6, length(uv)) * 0.15 + 0.85;
    gl_FragColor = vec4(color * fish_eye, 1.0);
}
`;

class CircularGallery {
    constructor(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl');
        if (!this.gl) {
            console.error('WebGL not supported');
            return;
        }

        // Добавляем класс preload к canvas для предотвращения анимации
        this.canvas.classList.add('preload');

        this.currentImage = null;
        this.startTime = performance.now();
        this.isInitialized = false;
        this.initialAnimationPlayed = false; // Добавляем флаг для отслеживания начальной анимации
        this.isInitialAnimationPlaying = false; // Флаг для блокировки обработки движения мыши во время начальной анимации
        
        // Инициализация переменных для отслеживания позиции мыши
        this.mousePosition = { x: 0.5, y: 0.5 };
        this.targetMousePosition = { x: 0.5, y: 0.5 };
        
        // Добавляем обработчики событий мыши на window
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (!isMobile) {
            window.addEventListener('mousemove', this.handleMouseMove.bind(this));
        }
        
        // Добавляем параметры для перехода
        this.params = {
            distortionStrength: 0,
            transition: 0,
            animationSpeed: 0,
            direction: 1 // 1 для вправо, -1 для влево
        };
        
        this.nextTexture = null;
        this.isTransitioning = false;
        
        this.isAnimating = true; // Начинаем с активной анимацией
        this.animationFrameId = null;
        this.lastMouseMoveTime = 0;
        this.mouseMoveTolerance = 0.0001;
        this.lastRenderTime = 0;
        this.needsConstantRender = true; // Флаг для постоянного рендеринга
        
        // Добавляем стили для предотвращения анимации при загрузке
        const style = document.createElement('style');
        style.textContent = `
            canvas[data-gallery="container"].preload {
                animation: none !important;
                transition: none !important;
            }
            canvas[data-gallery="container"].preload * {
                animation: none !important;
                transition: none !important;
            }
            
            /* Добавляем стили для управления навигацией */
            [data-gallery="swiper-nav"],
            [data-gallery="swiper-pag"] {
                visibility: hidden;
                opacity: 0;
            }
            [data-gallery="swiper-nav"].visible,
            [data-gallery="swiper-pag"].visible {
                transition: visibility 0.3s linear, opacity 0.6s linear;
                visibility: visible;
                opacity: 1;
            }
        `;
        document.head.appendChild(style);
        
        // Инициализация WebGL
        this.initWebGL();
        
        // Добавляем обработчик изменения размера окна
        window.addEventListener('resize', () => {
            this.startRenderLoop();
            // Останавливаем рендер через 100мс после последнего ресайза
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
                if (!this.isTransitioning && !this.isMouseMoving()) {
                    this.stopRenderLoop();
                }
            }, 100);
        });
        
        // Немедленно загружаем первое изображение
        this.loadImage();
    }
    
    // Добавляем методы управления рендер-циклом
    startRenderLoop() {
        if (!this.isAnimating) {
            this.isAnimating = true;
            this.animate(performance.now());
        }
    }
    
    stopRenderLoop() {
        // Не останавливаем рендеринг, если он необходим постоянно
        if (this.needsConstantRender) return;
        
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
        this.isAnimating = false;
    }
    
    isMouseMoving() {
        const now = performance.now();
        const timeSinceLastMove = now - this.lastMouseMoveTime;
        return timeSinceLastMove < 100;
    }
    
    handleMouseMove(event) {
        // Если идет начальная анимация, игнорируем движение мыши
        if (this.isInitialAnimationPlaying) return;
        
        const x = event.clientX / window.innerWidth;
        const y = 1 - event.clientY / window.innerHeight;
        
        this.targetMousePosition = {
            x: gsap.utils.clamp(0, 1, x),
            y: gsap.utils.clamp(0, 1, y)
        };
    }

    async updateImage(newImage, skipAnimation = false) {
        if (!this.gl || !newImage) {
            console.warn('GL context or image not available');
            return;
        }

        // Если это первое изображение или контекст не инициализирован
        if (!this.isInitialized || !this.currentImage) {
            this.gl.activeTexture(this.gl.TEXTURE0);
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, newImage);
            this.currentImage = newImage;
            this.isInitialized = true;
            this.startTime = performance.now();
            this.animate(this.startTime);
            return;
        }

        if (this.currentImage && this.currentImage.src === newImage.src) {
            return;
        }

        if (this.isTransitioning) {
            return;
        }

        this.isTransitioning = true;

        // Используем программу перед установкой униформ
        this.gl.useProgram(this.program);

        // Всегда загружаем новое изображение в следующую текстуру
        this.gl.activeTexture(this.gl.TEXTURE1);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.nextTexture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, newImage);
        this.gl.uniform1i(this.textureNextLocation, 1);

        if (skipAnimation) {
            this.gl.activeTexture(this.gl.TEXTURE0);
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, newImage);
            this.currentImage = newImage;
            this.isTransitioning = false;
            this.stopRenderLoop();
            return;
        }

        this.startRenderLoop();
        
        gsap.timeline()
            .to(this.params, {
                transition: 1,
                duration: 1.2,
                ease: "power2.inOut",
                onStart: () => {
                    // Триггерим событие начала перехода
                    const event = new CustomEvent('galleryTransitionStart', {
                        detail: { 
                            direction: this.params.direction,
                            activeIndex: window.gallerySwiper ? window.gallerySwiper.activeIndex : 0
                        }
                    });
                    this.canvas.dispatchEvent(event);
                    // Также диспатчим событие на document для удобства
                    document.dispatchEvent(new CustomEvent('galleryTransitionStart', {
                        detail: { 
                            direction: this.params.direction,
                            activeIndex: window.gallerySwiper ? window.gallerySwiper.activeIndex : 0
                        }
                    }));
                },
                onUpdate: () => {
                    this.gl.useProgram(this.program);
                    this.gl.uniform1f(this.transitionLocation, this.params.transition);
                    this.gl.uniform1f(this.directionLocation, this.params.direction);
                },
                onComplete: () => {
                    // По завершении анимации обновляем текущую текстуру
                    this.gl.activeTexture(this.gl.TEXTURE0);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, newImage);
                    this.currentImage = newImage;
                    this.params.transition = 0;
                    this.isTransitioning = false;
                    
                    // Очищаем следующую текстуру
                    this.gl.activeTexture(this.gl.TEXTURE1);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.nextTexture);
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));
                    
                    // Триггерим событие завершения перехода
                    const event = new CustomEvent('galleryTransitionComplete', {
                        detail: { 
                            direction: this.params.direction,
                            activeIndex: window.gallerySwiper ? window.gallerySwiper.activeIndex : 0
                        }
                    });
                    this.canvas.dispatchEvent(event);
                    // Также диспатчим событие на document для удобства
                    document.dispatchEvent(new CustomEvent('galleryTransitionComplete', {
                        detail: { 
                            direction: this.params.direction,
                            activeIndex: window.gallerySwiper ? window.gallerySwiper.activeIndex : 0
                        }
                    }));
                    
                    // Проверяем необходимость продолжения рендеринга
                    if (!this.needsConstantRender && !this.isMouseMoving()) {
                        this.stopRenderLoop();
                    }
                }
            });
    }

    async loadImage() {
        // Получаем все изображения галереи
        const galleryImages = document.querySelectorAll('[data-gallery="image"]');
        if (galleryImages.length === 0) {
            return;
        }

        // Находим первое реальное изображение (не плейсхолдер)
        let firstRealImage = null;
        for (let i = 0; i < galleryImages.length; i++) {
            const img = galleryImages[i];
            // Проверяем, что это не плейсхолдер
            if (img.src && !img.src.includes('placeholder')) {
                firstRealImage = img;
                break;
            }
        }

        if (!firstRealImage && galleryImages.length > 0) {
            firstRealImage = galleryImages[0];
        }

        if (!firstRealImage) {
            return;
        }

        try {
            console.log('Loading first image:', firstRealImage.src);
            const img = await imageLoader.load(firstRealImage.src);
            
            if (img) {
                console.log('First image loaded successfully');
                this.currentImage = img;
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img);
                this.isInitialized = true;

                // Копируем изображение в следующую текстуру для начальной анимации
                this.gl.activeTexture(this.gl.TEXTURE1);
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.nextTexture);
                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img);
                
                this.startTime = performance.now();
                this.animate(this.startTime);

                // Запускаем начальную анимацию после полной инициализации
                requestAnimationFrame(() => {
                    this.playInitialAnimation();
                });
            } else {
                console.error('Failed to load first image');
                this.isInitialized = true;
            }
        } catch (error) {
            console.error('Error loading first image:', error);
            this.isInitialized = true;
        }
    }

    playInitialAnimation() {
        if (this.initialAnimationPlayed || !this.isInitialized) return;
        
        console.log('Starting initial animation');
        
        // Убеждаемся, что все необходимые параметры инициализированы
        if (!this.gl || !this.program || !this.transitionLocation || !this.directionLocation) {
            console.error('WebGL not fully initialized');
            return;
        }

        // Сохраняем начальную позицию мыши (центр)
        const centerPosition = { x: 0.5, y: 0.5 };
        this.mousePosition = { ...centerPosition };
        this.targetMousePosition = { ...centerPosition };
        
        // Блокируем обработку движения мыши на время анимации
        this.isInitialAnimationPlaying = true;
        
        // Принудительно запускаем рендер-цикл
        this.startRenderLoop();
        this.isTransitioning = true;
        
        // Запускаем два полных оборота
        gsap.timeline()
            .fromTo(this.params, 
                {
                    transition: 0,
                    direction: -1
                },
                {
                    transition: 2, // Два полных оборота
                    duration: 2.5,
                    ease: "expo.inOut",
                    onStart: () => {
                        console.log('Initial animation started');
                    },
                    onUpdate: () => {
                        if (!this.gl || !this.program) return;
                        this.gl.useProgram(this.program);
                        this.gl.uniform1f(this.transitionLocation, this.params.transition);
                        this.gl.uniform1f(this.directionLocation, this.params.direction);
                    },
                    onComplete: () => {
                        console.log('Initial animation completed');
                        this.params.transition = 0;
                        this.isTransitioning = false;
                        this.initialAnimationPlayed = true;
                        this.isInitialAnimationPlaying = false; // Разблокируем обработку движения мыши
                        this.canvas.classList.remove('preload');
                        
                        // Показываем навигацию вместе с текстом
                        const swiperNavElement = document.querySelector('[data-gallery="swiper-nav"]');
                        if (swiperNavElement) {
                            swiperNavElement.classList.add('visible');
                        }
                        
                        // Показываем пагинацию
                        const swiperPagElement = document.querySelector('[data-gallery="swiper-pag"]');
                        if (swiperPagElement) {
                            swiperPagElement.classList.add('visible');
                        }
                        
                        // Удаляем класс initial-animation с body
                        document.body.classList.remove('initial-animation');
                        
                        // Диспатчим событие завершения начальной анимации
                        const event = new CustomEvent('galleryInitialAnimationComplete');
                        document.dispatchEvent(event);
                        
                        if (!this.needsConstantRender && !this.isMouseMoving()) {
                            this.stopRenderLoop();
                        }
                    }
                }
            );
    }

    createShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
            this.gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    initWebGL() {
        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, VERTEX_SHADER);
        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, FRAGMENT_SHADER);

        this.program = this.gl.createProgram();
        this.gl.attachShader(this.program, vertexShader);
        this.gl.attachShader(this.program, fragmentShader);
        this.gl.linkProgram(this.program);

        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
            console.error('Program link error:', this.gl.getProgramInfoLog(this.program));
            return;
        }

        // Создаем и инициализируем буферы
        const positions = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1,
        ]);

        const texCoords = new Float32Array([
            0, 1,
            1, 1,
            0, 0,
            1, 0,
        ]);

        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);

        this.texCoordBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, texCoords, this.gl.STATIC_DRAW);

        // Получаем локации атрибутов и униформ
        this.positionLocation = this.gl.getAttribLocation(this.program, 'aPosition');
        this.texCoordLocation = this.gl.getAttribLocation(this.program, 'aTexCoord');
        this.timeLocation = this.gl.getUniformLocation(this.program, 'uTime');
        this.resolutionLocation = this.gl.getUniformLocation(this.program, 'uResolution');
        this.mousePositionLocation = this.gl.getUniformLocation(this.program, 'uMousePosition');

        // Создаем и настраиваем текстуру
        this.texture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        
        // Устанавливаем параметры текстуры
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        
        // Создаем пустую текстуру нужного размера
        const width = 1;
        const height = 1;
        const pixels = new Uint8Array([0, 0, 0, 255]);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);

        // Создаем текстуру для следующего изображения
        this.nextTexture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.nextTexture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        
        // Создаем пустую текстуру
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);

        // Получаем локации униформ для перехода
        this.transitionLocation = this.gl.getUniformLocation(this.program, 'uTransition');
        this.textureNextLocation = this.gl.getUniformLocation(this.program, 'uTextureNext');
        this.directionLocation = this.gl.getUniformLocation(this.program, 'uDirection');
    }

    resizeCanvas() {
        const displayWidth = this.canvas.clientWidth;
        const displayHeight = this.canvas.clientHeight;

        if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {
            this.canvas.width = displayWidth;
            this.canvas.height = displayHeight;
            this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
        }
    }

    render(time) {
        this.resizeCanvas();

        const interpolationFactor = 0.1;
        this.mousePosition.x += (this.targetMousePosition.x - this.mousePosition.x) * interpolationFactor;
        this.mousePosition.y += (this.targetMousePosition.y - this.mousePosition.y) * interpolationFactor;

        this.gl.clearColor(0, 0, 0, 1);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);

        if (!this.currentImage) return;

        this.gl.useProgram(this.program);

        // Устанавливаем униформы
        this.gl.uniform1f(this.timeLocation, (time - this.startTime) / 1000);
        this.gl.uniform2f(this.resolutionLocation, this.gl.canvas.width, this.gl.canvas.height);
        this.gl.uniform2f(this.mousePositionLocation, this.mousePosition.x, this.mousePosition.y);
        this.gl.uniform1f(this.transitionLocation, this.params.transition);
        this.gl.uniform1f(this.directionLocation, this.params.direction);

        // Активируем и привязываем текстуры
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.uniform1i(this.gl.getUniformLocation(this.program, 'uTexture'), 0);

        this.gl.activeTexture(this.gl.TEXTURE1);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.nextTexture);
        this.gl.uniform1i(this.textureNextLocation, 1);

        // Устанавливаем атрибуты и рисуем
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.enableVertexAttribArray(this.positionLocation);
        this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, false, 0, 0);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
        this.gl.enableVertexAttribArray(this.texCoordLocation);
        this.gl.vertexAttribPointer(this.texCoordLocation, 2, this.gl.FLOAT, false, 0, 0);

        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }

    animate(time) {
        if (!this.isAnimating) return;
        
        this.render(time);
        
        // Всегда продолжаем анимацию, если требуется постоянный рендеринг
        if (this.needsConstantRender || this.isTransitioning || this.isMouseMoving()) {
            this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
        } else {
            this.stopRenderLoop();
        }
    }
}

// Инициализация при загрузке страницы
window.addEventListener('DOMContentLoaded', () => {
    // Добавляем класс initial-animation к body
    document.body.classList.add('initial-animation');
    
    window.circularGalleries = [];
    
    function initializeGallery() {
        const canvases = document.querySelectorAll('canvas[data-gallery="container"]');
        const galleryImages = document.querySelectorAll('[data-gallery="image"]');
        
        if (canvases.length === 0) {
            return false;
        }
        
        canvases.forEach(canvas => {
            if (canvas.hasAttribute('data-gallery-initialized')) {
                return;
            }
            
            const gallery = new CircularGallery(canvas);
            canvas.setAttribute('data-gallery-initialized', 'true');
            window.circularGalleries.push(gallery);
            
            canvas.addEventListener('galleryImageChange', async (event) => {
                if (event.detail && event.detail.imageUrl) {
                    try {
                        const img = await imageLoader.load(event.detail.imageUrl);
                        gallery.updateImage(img);
                    } catch (error) {
                        console.error('Failed to load image:', error);
                    }
                }
            });
        });
        
        return true;
    }
    
    // Пытаемся инициализировать сразу
    let initialized = initializeGallery();
    
    if (!initialized) {
        // Если не удалось, пробуем еще раз после короткой задержки
        requestAnimationFrame(() => {
            initialized = initializeGallery();
        });
    }
    
    // Инициализируем Swiper с задержкой
    setTimeout(initializeSwiperGallery, 500);
});

function initializeSwiperGallery() {
    if (typeof Swiper === 'undefined') {
        console.error('Swiper is not loaded');
        return;
    }

    const swiperElement = document.querySelector('[data-gallery="swiper"]');
    if (!swiperElement) return;

    try {
        const swiper = new Swiper('[data-gallery="swiper"]', {
            wrapperClass: 'swiper-cover_wrapper',
            slideClass: 'swiper-cover_slide',
            slidesPerView: 1,
            spaceBetween: 0,
            loop: true,
            effect: "fade",
            fadeEffect: { crossFade: true },
            observer: true,
            observeParents: true,
            touchEventsTarget: 'wrapper',
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            reverseDirection: true,
            // autoplay: { delay: 5000, disableOnInteraction: false, pauseOnMouseEnter: true },
            keyboard: { enabled: true, onlyInViewport: true },
            navigation: {
                nextEl: '[data-gallery="next"]',
                prevEl: '[data-gallery="prev"]'
            },
            pagination: {
                el: '.swiper-pagination',
                clickable: true,
                renderBullet: function(index, className) {
                    return '<span class="' + className + '"></span>';
                }
            },
            on: {
                init: function() {
                    // Mark first bullet as active and filled
                    const bullets = document.querySelectorAll('.swiper-pagination-bullet');
                    if (bullets.length > 0) {
                        bullets[0].classList.add('filled');
                    }

                    // Add space key handler
                    document.addEventListener('keydown', (e) => {
                        if (e.code === 'Space') {
                            e.preventDefault();
                            if (this.autoplay.running) {
                                this.autoplay.stop();
                            } else {
                                this.autoplay.start();
                            }
                        }
                    });
                },
                slideChange: function() {
                    // Pagination update logic
                    const bullets = document.querySelectorAll('.swiper-pagination-bullet');
                    const activeIndex = this.realIndex;

                    // Update filled state for all bullets
                    bullets.forEach((bullet, index) => {
                        if (index === activeIndex) {
                            bullet.classList.add('filled');
                        } else {
                            bullet.classList.remove('filled');
                        }
                    });
                    
                    // Image change logic
                    const canvas = document.querySelector('[data-gallery="container"]');
                    const slides = Array.from(this.slides);
                    const activeSlide = slides[this.activeIndex];
                    const img = activeSlide.querySelector('[data-gallery="image"]');

                    if (canvas && img && !img.src.includes('placeholder')) {
                        const event = new CustomEvent('galleryImageChange', {
                            detail: { 
                                imageUrl: img.src,
                                direction: window.circularGalleries[0]?.params.direction
                            }
                        });
                        canvas.dispatchEvent(event);
                    }
                },
                navigationNext: function() {
                    if (window.circularGalleries?.[0]) {
                        window.circularGalleries[0].params.direction = -1;
                    }
                },
                navigationPrev: function() {
                    if (window.circularGalleries?.[0]) {
                        window.circularGalleries[0].params.direction = 1;
                    }
                },
                touchStart: function() {
                    const startX = this.touches.startX;
                    this.on('touchMove', () => {
                        if (window.circularGalleries?.[0]) {
                            window.circularGalleries[0].params.direction = 
                                this.touches.currentX - startX > 0 ? -1 : 1;
                        }
                    });
                }
            }
        });
        window.gallerySwiper = swiper;
    } catch (error) {
        console.error('Swiper initialization error:', error);
    }
}

// Добавляем стиль для скрытия плейсхолдера
(function() {
    // Создаем стиль для скрытия плейсхолдера
    const style = document.createElement('style');
    style.textContent = `
        img[src*="placeholder.60f9b1840c.svg"] {
            opacity: 0 !important;
            visibility: hidden !important;
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            overflow: hidden !important;
        }
    `;
    document.head.appendChild(style);
    
    // Добавляем обработчик ошибок для всех изображений
    window.addEventListener('DOMContentLoaded', () => {
        const images = document.querySelectorAll('[data-gallery="image"]');
        images.forEach(img => {
            img.onerror = function() {
                // Если это плейсхолдер, игнорируем ошибку
                if (this.src && this.src.includes('placeholder')) {
                    return true;
                }
            };
        });
    });
})();